var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"E. Hiyama, Y. Kino and M. Kamimura. Gaussian Expansion Method for Few-Body Systems. Prog. Part. Nucl. Phys. 51, 223–307 (2003).\n\n\n\nL. Happ, M. Zimmermann, S. I. Betelu, W. P. Schleich and M. A. Efremov. Universality in a one-dimensional three-body system. Phys. Rev. A 100, 012709 (2019).\n\n\n\nS. Bubin, E. Bednarz and L. Adamowicz. Charge asymmetry in HD+. The Journal of Chemical Physics 122, 041102 (2005).\n\n\n\nA. M. Frolov. Bound-state properties of the positronium negative ion Ps^-. Phys. Rev. A 60, 2834–2839 (1999).\n\n\n\n","category":"page"},{"location":"ISGL_ps-/#Three-body-Coulomb-problem-in-3D:-ps-(electron,-electron,-positron)","page":"3D: ps- system","title":"Three-body Coulomb problem in 3D: ps- (electron, electron, positron)","text":"","category":"section"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"In this example we solve the three-body Coulomb problem of two electrons and a positron in 3D using the ISGL module. The code calculates the bound states and observables like the mean radii between two of the three particles. The results are compared with the high-precision literature values of Ref. [4].","category":"page"},{"location":"ISGL_ps-/#Setup","page":"3D: ps- system","title":"Setup","text":"","category":"section"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"using Printf, FewBodyToolkit","category":"page"},{"location":"ISGL_ps-/#Input-parameters:","page":"3D: ps- system","title":"Input parameters:","text":"","category":"section"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"Define pair-interactions:","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"vee(r) = +1/r #electron-electron: V12\nvep(r) = -1/r #positron-electron: V31, V23","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"Physical parameters","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"mass_arr=[1.0,1.0,1.0] # array of masses of particles (m1,m2,m3), here: electron, electron, positron\nsvals=[\"b\",\"b\",\"z\"] # since the two electrons are in asymmetric spin states, we can treat them as bosons for the spatial part\nphys_params = make_phys_params3B3D(;mass_arr, svals, vint_arr=[[vep],[vep],[vee]]);\nnothing #hide","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"Numerical parameters:","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"gp = (;nmax=10,Nmax=10,r1=0.1,rnmax=25.0,R1=0.1,RNmax=25.0)\nnum_params = make_num_params3B3D(;gem_params=gp);\nnothing #hide","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"In this example we also calculate central observables like the mean radii (and squared radii) between two of the three particles. With \"central\", we mean observables of any form that only depend on r, the direct distance between two particles. For this we define the observables as functions:","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"rad(r) = r # radius\ninvrad(r) = 1/r # inverse radius\nrad2(r) = r^2; # squared radius\nnothing #hide","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"The code also allows for the observable langle R^2rangle in the other Jacobi coordinate, via the input R2_arr.","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"stateindices = [1] # for which states to calculate observables\nobserv_params = (stateindices,centobs_arr = [[rad,invrad,rad2],[rad,invrad,rad2],[rad,invrad,rad2]],R2_arr = [1,1,1] ) # R2_arr=[0,0,0] means no R^2 calculation","category":"page"},{"location":"ISGL_ps-/#Obtaining-energies-and-observables","page":"3D: ps- system","title":"Obtaining energies and observables","text":"","category":"section"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"Using the optional keyword argument observ_params (together with wf_bool=1) we can obtain the results for the observables on-the-fly. The energies are stored in the energies array, the eigenvectors in wfs, and the central observables in co_out. The mean squared radii for the R-coordinate are stored in R2_out.","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"energies,wfs,co_out,R2_out = ISGL.ISGL_solve(phys_params,num_params;observ_params,wf_bool=1);\nnothing #hide","category":"page"},{"location":"ISGL_ps-/#Comparison-with-literature-values","page":"3D: ps- system","title":"Comparison with literature values","text":"","category":"section"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"simax = 1 # only 1 bound state\nnum_arr = energies[1:simax];\nex_arr = -[0.262005070232978][1:simax]; # literature value for the energy\nnothing #hide","category":"page"},{"location":"ISGL_ps-/#Energy-spectrum","page":"3D: ps- system","title":"Energy spectrum","text":"","category":"section"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"println(\"ps-:  binding energy:\")\ncomparison(num_arr, ex_arr, simax; s1=\"Numeric\", s2=\"Literature\")\nprintln(\"---------------------------------------------------\")","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"We find good agreement with the literature value.","category":"page"},{"location":"ISGL_ps-/#Mean-values-for-the-radii,-inverse-radii,-and-squared-radii-for-the-r-coordinate","page":"3D: ps- system","title":"Mean values for the radii, inverse radii, and squared radii for the r-coordinate","text":"","category":"section"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"Literature values for radii (ee indicates the electron-electron distance, and pe the positron-electron distance):","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"ree_lit = [8.54858] #r21\nrpe_lit = [5.48963] #r31\nr_lit = [rpe_lit,rpe_lit,ree_lit];\nnothing #hide","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"... inverse radii:","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"iree_lit = [0.15563] #1/r21\nirpe_lit = [0.33982] #1/r31\nir_lit = [irpe_lit,irpe_lit,iree_lit];\nnothing #hide","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"... and square radii:","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"ree2_lit = [93.1786] #r21^2\nrpe2_lit = [48.4189] #r31^2\nr2_lit = [rpe2_lit,rpe2_lit,ree2_lit];\nnothing #hide","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"Comparison of the numerical results with the literature:","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"println(\"\\nps-:  radii ⟨r⟩ with differences\")\nstrings = [\"r_pe\",\"r_pe\",\"r_ee\"]\nfor ii in [1,2,3]\n    comparison(co_out[ii,1,stateindices], r_lit[ii], simax; s1=strings[ii], s2=string(strings[ii],\"(lit)\"))\nend\nprintln(\"---------------------------------------------------\")\n\nprintln(\"\\nps-:  inverse radii ⟨1/r⟩ with differences\")\nstrings = [\"1/r_pe\",\"1/r_pe\",\"1/r_ee\"]\nfor ii in [1,2,3]\n    comparison(co_out[ii,2,stateindices], ir_lit[ii], simax; s1=strings[ii], s2=string(strings[ii],\"(lit)\"))\nend\nprintln(\"---------------------------------------------------\")\n\nprintln(\"\\nps-:  squared radii ⟨r²⟩ with differences\")\nstrings2 = [\"r²_pe\",\"r²_pe\",\"r²_ee\"]\nfor ii in [1,2,3]\n    comparison(co_out[ii,3,stateindices], r2_lit[ii], simax; s1=strings2[ii], s2=string(strings2[ii],\"(lit)\"))\nend\nprintln(\"---------------------------------------------------\")","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"Since there is only one bound state, we can reproduce both energies and geometric properties with good accuracy. In contrast, the HD+ system supports several excited states, whose geometric properties are difficult to describe by the simple centered Gaussian basis functions.","category":"page"},{"location":"ISGL_ps-/#Mean-squared-radii-for-the-R-coordinate","page":"3D: ps- system","title":"Mean squared radii for the R-coordinate","text":"","category":"section"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"For this observable the reference does not provide any direct comparison value, so we just print the numerical results:","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"println(\"\\nps+:  Mean squared radii ⟨R²⟩\")\nrow_labels = [\"Electron 1 rel. to (e-_2,p+) pair:  \", \"Electron 2 rel. to (p+,e-_1) pair:  \", \"Positron rel. to (e-_1,e-_2) pair:  \"]\nstate_labels = [\"Ground state\"]\nprintln(rpad(\" ⟨R²⟩ \", 37), join(state_labels, \"   \"))\nfor i in 1:length(row_labels)\n    print(rpad(row_labels[i], 30))\n    for j in 1:length(state_labels)\n        print(@sprintf(\"%10.4f\", R2_out[i, j]))\n    end\n    println()\nend","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"Since particles 1 and 2 are identical electrons, the first two rows are identical. The third row shows the results for the positron with respect to the center-of-mass of the electron-electron pair and are clearly smaller, probably since it feels an attractive Coulomb force of twice the strength (the effective pair of the two electrons has charge -2).","category":"page"},{"location":"ISGL_ps-/#Page-References","page":"3D: ps- system","title":"Page References","text":"","category":"section"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"A. M. Frolov. Bound-state properties of the positronium negative ion Ps^-. Phys. Rev. A 60, 2834–2839 (1999).\n\n\n\n","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"See also the full bibliography for further references cited throughout this documentation.","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"","category":"page"},{"location":"ISGL_ps-/","page":"3D: ps- system","title":"3D: ps- system","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ISGL_HD+/#Three-body-Coulomb-problem-in-3D:-HD-(proton,-deuteron,-electron)","page":"3D: HD+ system","title":"Three-body Coulomb problem in 3D: HD+ (proton, deuteron, electron)","text":"","category":"section"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"In this example we solve the three-body Coulomb problem of a proton, deuteron and electron in 3D using the ISGL module. The code calculates the bound states and observables like the mean radii between two of the three particles. The results are compared with the high-precision literature values of Ref. [3].","category":"page"},{"location":"ISGL_HD+/#Setup","page":"3D: HD+ system","title":"Setup","text":"","category":"section"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"using Printf, FewBodyToolkit","category":"page"},{"location":"ISGL_HD+/#Input-parameters:","page":"3D: HD+ system","title":"Input parameters:","text":"","category":"section"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"Define pair-interactions:","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"vde(r) = -1/r #deuteron-electron = V23 = V1\nvep(r) = -1/r #electron-proton = V31 = V2\nvpd(r) = +1/r; #proton-deuteron = V12 = V3\nnothing #hide","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"Physical parameters","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"mass_arr=[1836.15267343,3670.48296788,1.00] # array of masses of particles (m1,m2,m3), here: proton, deuteron, electron\nphys_params = make_phys_params3B3D(;mass_arr,vint_arr=[[vde],[vep],[vpd]]);\nnothing #hide","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"Numerical parameters:","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"gp = (;nmax=25,Nmax=25,r1=0.1,rnmax=25.0,R1=0.1,RNmax=25.0)\nnum_params = make_num_params3B3D(;gem_params=gp);\nnothing #hide","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"In this example we also calculate central observables like the mean radii (and squared radii) between two of the three particles. With \"central\", we mean observables of any form that only depend on r, the direct distance between two particles. For this we define the observables as functions:","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"rad(r) = r # radius\nrad2(r) = r^2; # squared radius\nnothing #hide","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"The code also allows for the observable langle R^2rangle in the other Jacobi coordinate, via the input R2_arr.","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"stateindices = 1:3 # for which states to calculate observables\nobserv_params = (stateindices,centobs_arr = [[rad,rad2],[rad,rad2],[rad,rad2]],R2_arr = [1,1,1] ) # R2_arr=[0,0,0] means no R^2 calculation","category":"page"},{"location":"ISGL_HD+/#Obtaining-energies-and-observables","page":"3D: HD+ system","title":"Obtaining energies and observables","text":"","category":"section"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"Using the optional keyword argument observ_params (together with wf_bool=1) we can obtain the results for the observables on-the-fly. The energies are stored in the energies array, the eigenvectors in wfs, and the central observables in co_out. The mean squared radii for the R-coordinate are stored in R2_out.","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"energies,wfs,co_out,R2_out = ISGL.ISGL_solve(phys_params,num_params;observ_params,wf_bool=1);\nnothing #hide","category":"page"},{"location":"ISGL_HD+/#Comparison-with-literature-values","page":"3D: HD+ system","title":"Comparison with literature values","text":"","category":"section"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"compmax = min(6,lastindex(energies));\nnum_arr = energies[1:compmax];\nex_arr = -[0.5978979685,0.5891818291,0.5809037001,0.5730505464,0.5656110418,0.5585755200][1:compmax]; # literature values for the energies\nnothing #hide","category":"page"},{"location":"ISGL_HD+/#Energy-spectrum","page":"3D: HD+ system","title":"Energy spectrum","text":"","category":"section"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"println(\"HD+:  Energies:\")\ncomparison(num_arr, ex_arr, compmax; s1=\"Numeric\", s2=\"Literature\")\nprintln(\"---------------------------------------------------\")","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"We find good agreement with the values of the literature, with deviations between 10^-3 and a few percent.","category":"page"},{"location":"ISGL_HD+/#Mean-radii,-and-squared-radii-for-the-r-coordinate","page":"3D: HD+ system","title":"Mean radii, and squared radii for the r-coordinate","text":"","category":"section"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"Literature values for radii (dp indicates deuteron-proton distance, de for deuteron-electron, and pe for proton-electron):","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"rdp_lit = [2.055,2.171,2.292,2.417,2.547,2.683][stateindices]\nrde_lit = [1.688,1.750,1.813,1.880,1.948,2.020][stateindices]\nrpe_lit = [1.688,1.750,1.814,1.881,1.950,2.022][stateindices]\nr_lit = [rde_lit,rpe_lit,rdp_lit];\nnothing #hide","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"... and square radii:","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"rdp2_lit = [4.268,4.855,5.492,6.185,6.942,7.771][stateindices]\nrde2_lit = [3.534,3.839,4.169,4.526,4.915,5.339][stateindices]\nrpe2_lit = [3.537,3.843,4.173,4.531,4.921,5.346][stateindices]\nr2_lit = [rde2_lit,rpe2_lit,rdp2_lit];\nnothing #hide","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"Comparison of the numerical results with the literature:","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"println(\"\\nHD+:  radii ⟨r⟩ with differences\")\nstrings = [\"r_de\", \"r_pe\", \"r_dp\"]\nfor ii in [3,1,2]\n    comparison(co_out[ii,1,stateindices], r_lit[ii], 3; s1=strings[ii], s2=string(strings[ii],\"(lit)\"))\nend\nprintln(\"---------------------------------------------------\")\n\nprintln(\"\\nHD+:  squared radii ⟨r²⟩ with differences\")\nstrings2 = [\"r²_de\", \"r²_pe\", \"r²_dp\"]\nfor ii in [3,1,2]\n    comparison(co_out[ii,2,stateindices], r2_lit[ii], 3; s1=strings2[ii], s2=string(strings2[ii],\"(lit)\"))\nend\nprintln(\"---------------------------------------------------\")","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"For the mean radii, the results for the ground state are still quite good, however accuracy decreases quickly for higher excited states. The repulsive Coulomb interaction between proton and deuteron poses a difficult problem for the centered Gaussian basis functions. Accordingly, the largest deviations are found for the (squared) radii of the proton-deuteron pair. Other types of basis functions might prove more suitable to capture the details of the system.","category":"page"},{"location":"ISGL_HD+/#Mean-squared-radii-for-the-R-coordinate","page":"3D: HD+ system","title":"Mean squared radii for the R-coordinate","text":"","category":"section"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"For this observable the reference does not provide any values, so we just print the numerical results:","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"println(\"\\nHD+:  Mean squared radii ⟨R²⟩\")\nrow_labels = [\"Proton rel. to (D+,e-) pair:  \", \"Deuteron rel. to (e-,p+) pair:\", \"Electron rel. to (p+,D+) pair:\"]\nstate_labels = [\"State 1\", \"State 2\", \"State 3\"]\nprintln(rpad(\" ⟨R²⟩ \", 34), join(state_labels, \"   \"))\nfor i in 1:length(row_labels)\n    print(rpad(row_labels[i], 30))\n    for j in 1:length(state_labels)\n        print(@sprintf(\"%10.4f\", R2_out[i, j]))\n    end\n    println()\nend","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"Due to the almost negligible mass of the electron, the results for ⟨R²⟩ in the first two rows are almost identical and also almost match to the first column of the mean radii ⟨r²⟩ between proton and deuteron. The third row shows the results for the electron with respect to the center-of-mass of the proton-deuteron pair and are clearly smaller, probably since it feels an attractive Coulomb force of twice the strength (the effective pair of proton and deuteron has charge +2).","category":"page"},{"location":"ISGL_HD+/#Page-References","page":"3D: HD+ system","title":"Page References","text":"","category":"section"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"S. Bubin, E. Bednarz and L. Adamowicz. Charge asymmetry in HD+. The Journal of Chemical Physics 122, 041102 (2005).\n\n\n\n","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"See also the full bibliography for further references cited throughout this documentation.","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"","category":"page"},{"location":"ISGL_HD+/","page":"3D: HD+ system","title":"3D: HD+ system","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example1D/#1D-Example:-Two-particles-with-Pöschl–Teller-interaction","page":"1D Example","title":"1D Example: Two particles with Pöschl–Teller interaction","text":"","category":"section"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"This example demonstrates how to use the FewBodyToolkit.jl package to compute bound states for two particles in 1D. Here we use the Pöschl–Teller interaction, since it has analytic solutions. In relative coordinates, this system is equivalent to a single particle in a potential. It is governed by the following Schrödinger equation (hbar mu=1) \\[ -\\frac{1}{2} \\frac{d^2}{dr^2}\\psi + V(r)\\psi = E\\psi \\] with the Pöschl–Teller potential \\[ V(r) = -\\frac{\\lambda(\\lambda+1)}{2} \\frac{1}{\\cosh^2(r)}. \\]","category":"page"},{"location":"example1D/#Setup","page":"1D Example","title":"Setup","text":"","category":"section"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"using Printf, Interpolations, Antique, FewBodyToolkit","category":"page"},{"location":"example1D/#Input-parameters","page":"1D Example","title":"Input parameters","text":"","category":"section"},{"location":"example1D/#Physical-parameters","page":"1D Example","title":"Physical parameters","text":"","category":"section"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"mass_arr=[1.0,Inf] # this ensures a reduced mass of 1.0\nmur = 1/(1/mass_arr[1]+1/mass_arr[2]) # reduced mass\nlambda=8.0\n\nfunction v_poschl(r)\n    return -lambda*(lambda+1)/2/mur*1/cosh(r)^2\nend;\nnothing #hide","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"We define the physical parameters as a NamedTuple which carries the information about the Hamiltonian.","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"phys_params = make_phys_params2B(;mur,vint_arr=[v_poschl],dim=1)","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"By leaving out the optional parameters, we use the defaults:","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"lmin = lmax = 0: minimum and maximum angular momentum (in 1D this corresponds to even states)\nhbar = 1.0: when working in dimensionless units","category":"page"},{"location":"example1D/#Numerical-parameters","page":"1D Example","title":"Numerical parameters","text":"","category":"section"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"nmax=6 # number of Gaussian basis functions\nr1=0.1;rnmax=10.0; # r1 and rnmax defining the widths of the basis functions\ngem_params = (;nmax,r1,rnmax);\nnothing #hide","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"We define the numerical parameters as a NamedTuple:","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"num_params = make_num_params2B(;gem_params)","category":"page"},{"location":"example1D/#1.-Numerical-solution","page":"1D Example","title":"1. Numerical solution","text":"","category":"section"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"We solve the two-body system by calling GEM2B_solve.","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"energies_arr = GEM2B_solve(phys_params,num_params)","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"Determine the number of bound states","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"simax = findlast(energies_arr.<0)","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"The Pöschl–Teller potential has lambda = 8 eigenvalues. In this example we focus on the even states, hence there are only 4 bound states. Their energies can be found exactly: \\[ E_n = -\\frac{(\\lambda-n)^2}{2\\mu} \\] where n = 1 2   lambda-1 is the state index. The package Antique.jl provides these exact energies in a convenient way.","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"PT = Antique.PoschlTeller(λ=8)\nex_arr = [Antique.E(PT,n=i) for i=0:2:Int(floor(lambda-1))]\n\nprintln(\"1. Numerical solution of the 1D problem:\")\ncomparison(energies_arr, ex_arr, simax)","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"So far, the numerical solutions are not very accurate. This is because the basis parmeters are not optimal.","category":"page"},{"location":"example1D/#2.-Optimization-of-basis-parameters","page":"1D Example","title":"2. Optimization of basis parameters","text":"","category":"section"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"We can optimize the basis parameters for a specific state indicated by stateindex using GEM_Optim_2B.","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"stateindex = 4 # which state to optimize for\nparams_opt = GEM2B.GEM_Optim_2B(phys_params, num_params, stateindex)\ngem_params_opt = (;nmax, r1 = params_opt[1], rnmax = params_opt[2])\nnum_params_opt = make_num_params2B(;gem_params=gem_params_opt)\ne2_opt = GEM2B.GEM2B_solve(phys_params,num_params_opt)\n\nprintln(\"\\n2. Optimization of GEM parameters for E2[$stateindex]:\")\n@printf(\"%-15s %-15s %-15s %-15s %-15s\\n\", \"r1\", \"rnmax\", \"E2[$(stateindex-1)]\", \"E2[$stateindex]\", \"E2[$(stateindex+1)]\")\n\nprintln(\"Before optimization:\")\n@printf(\"%-15.6f %-15.6f %-15.6f %-15.6f %-15.6f\\n\", gem_params.r1, gem_params.rnmax, energies_arr[stateindex-1], energies_arr[stateindex], energies_arr[stateindex+1])\n\nprintln(\"After optimization:\")\n@printf(\"%-15.6f %-15.6f %-15.6f %-15.6f %-15.6f\\n\", gem_params_opt.r1, gem_params_opt.rnmax, e2_opt[stateindex-1], e2_opt[stateindex], e2_opt[stateindex+1])","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"With the optimized parameters, the exact energies are reproduced very well, using only 6 basis functions.","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"comparison(e2_opt, ex_arr, simax; s1=\"Optimized\")","category":"page"},{"location":"example1D/#3.-Using-an-interpolated-interaction","page":"1D Example","title":"3. Using an interpolated interaction","text":"","category":"section"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"We can also create a potential from interpolated data.","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"r_arr = -10.0:0.5:10.0\nv_arr = v_poschl.(r_arr)\nv_interpol = cubic_spline_interpolation(r_arr,v_arr,extrapolation_bc=Line())\nv_int(r) = v_interpol(r); # we have to transform the interaction to an object of type \"function\"\nnothing #hide","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"As input to the solver we need to define new physical parameters with the interpolated interaction. Moreover, we use the optimized numerical parameters from the previous step.","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"phys_params_interpol = make_phys_params2B(;mur,vint_arr=[v_int],dim=1)\n\nprintln(\"\\n3. Numerical solution using an interpolated interaction:\")\nenergies_interpol = GEM2B_solve(phys_params_interpol,num_params_opt)\ncomparison(energies_interpol, e2_opt, simax;s1=\"Interpolated\", s2=\"Optimized\")","category":"page"},{"location":"example1D/#4.-Inverse-problem:-Tuning-the-potential-strength","page":"1D Example","title":"4. Inverse problem: Tuning the potential strength","text":"","category":"section"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"We can use v0GEMOptim to scale the interaction such that the state indicated by stateindex has a fixed energy target_e2. At the same time, the basis parameters are optimized for this state.","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"stateindex = 3; target_e2 = -18.0;\nprintln(\"\\n4. Scaling the potential such that E2[$stateindex] = $target_e2:\")\n@time phys_params_scaled,num_params_scaled,vscale = GEM2B.v0GEMOptim(phys_params,num_params,stateindex,target_e2)\ne2_v0 = GEM2B.GEM2B_solve(phys_params_scaled,num_params_scaled)\n\nprintln(\"After scaling:\")\n@printf(\"%-15s %-15s %-15s %-15s %-15s\\n\", \"r1\", \"rnmax\", \"E2[$(stateindex-1)]\", \"E2[$stateindex]\", \"E2[$(stateindex+1)]\")\n@printf(\"%-15.6f %-15.6f %-15.6f %-15.6f %-15.6f\\n\", num_params_scaled.gem_params.r1, num_params_scaled.gem_params.rnmax, e2_v0[stateindex-1], e2_v0[stateindex], e2_v0[stateindex+1])","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"Here, we scale the potential such that the energy of the state with stateindex = 3 is equal to target_e2 = -18.0. So far this was the energy of the state with index 2. For this special potential, this corresponds therefore to increasing the number of states and lambda by 2. Hence, the we expect the scaling factor to be approximately (lambda+2)(lambda+2+1)(lambda(lambda+1))","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"println(\"vscale = $(round(vscale,digits=8)) should be approximately (λ+2)*(λ+2+1)/(λ*(λ+1)) = \", round((lambda+2)*(lambda+2+1)/(lambda*(lambda+1)),digits=8) )","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"A much more efficient way to solve the inverse problem is to use the inverse_bool option in GEM2B_solve. This finds the critical values of v0 as eigenvalues of a generalized eigenvalue problem for which the energy is close to target_energy. Note, however that this does not optimize the basis parameters on-the-fly. If the basis is not optimal, the results might not be very accurate. Moreover, a different threshold in num_params might be required.","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"println(\"\\n4b. Using the inverse_bool option in GEM2B_solve to find the critical values of v0:\")\n@time v0crits = GEM2B.GEM2B_solve(phys_params,num_params_scaled,inverse_bool=1,target_energy=target_e2)\nprintln(\"v0crits[3] = $(round(v0crits[3],digits=8)), should be close to \", round((lambda+2)*(lambda+2+1)/(lambda*(lambda+1)),digits=8) )","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"","category":"page"},{"location":"example1D/","page":"1D Example","title":"1D Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"3B1D_23body/#Consistency-check-with-two-body-module-GEM2B","page":"1D: Consistency with 2-body","title":"Consistency check with two-body module GEM2B","text":"","category":"section"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"In this example we show how to reproduce two-body results using the three-body code. This is a good test for new features of a three-body code and whenever there are no other known results to compare to.","category":"page"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"For that we use only one interaction between particles 1 and 2, i.e. particle 3 remains a spectator. Moreover, we employ only a single basis function to describe the relative motion of particle 3 relative to the center of mass of particles 1 and 2. This ensures minimal impact on the two-body subsystem and hence reproduces the two-body results.","category":"page"},{"location":"3B1D_23body/#Setup","page":"1D: Consistency with 2-body","title":"Setup","text":"","category":"section"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"using Printf, Plots, FewBodyToolkit","category":"page"},{"location":"3B1D_23body/#Input-parameters:","page":"1D: Consistency with 2-body","title":"Input parameters:","text":"","category":"section"},{"location":"3B1D_23body/#Physical-parameters","page":"1D: Consistency with 2-body","title":"Physical parameters","text":"","category":"section"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"We use only a single interaction between particles 1 and 2. Particle 3 therefore does not interact and acts as a spectator.","category":"page"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"v2(r) = -40 * 1/(1+r^4)\nvint_arr=[[],[],[v2]] #[[v23],[v31],[v12]]\n\nmass_arr = [1.0,20.0,20.0]# array of masses of particles (m1,m2,m3)\nmur = 1/(1/mass_arr[1]+1/mass_arr[2]) # reduced mass\n\nphys_params2B = make_phys_params2B(;mur,vint_arr=vint_arr[3],dim=1)\nphys_params3B = make_phys_params3B1D(;mass_arr,vint_arr)","category":"page"},{"location":"3B1D_23body/#Numerical-parameters","page":"1D: Consistency with 2-body","title":"Numerical parameters","text":"","category":"section"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"For the R- Jacobi coordinate we use only a single basis function with a very large range. This ensures the contribution from the kinetic energy operator corresponding to this Jacobi-coordinate is negligible.","category":"page"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"nmax = 8; r1=1.0;rnmax=10.0;\nnum_params2B = make_num_params2B(;gem_params=(;nmax, r1, rnmax))\nnum_params3B = make_num_params3B1D(;gem_params=(;nmax, r1, rnmax, Nmax= 1, R1=10000.0, RNmax=10000.0))","category":"page"},{"location":"3B1D_23body/#Numerical-solution","page":"1D: Consistency with 2-body","title":"Numerical solution","text":"","category":"section"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"e2 = GEM2B.GEM2B_solve(phys_params2B,num_params2B);\ne3 = GEM3B1D.GEM3B1D_solve(phys_params3B,num_params3B);\nnothing #hide","category":"page"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"Determine the number of bound states","category":"page"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"simax = findlast(e2.<0)","category":"page"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"Since particle 3 only acts as a spectator, the three-body system is effectively a two-body system. We can compare the results of the two codes. The three-body code can reproduce the two-body results, as it should:","category":"page"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"println(\"Check if we can recover 2-body results with the 3-body code:\")\ncomparison(e2,e3,simax;s1=\"2-body\",s2=\"3-body\")","category":"page"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"","category":"page"},{"location":"3B1D_23body/","page":"1D: Consistency with 2-body","title":"1D: Consistency with 2-body","text":"This page was generated using Literate.jl.","category":"page"},{"location":"AdvancedOptions/#Advanced-options","page":"Advanced Options","title":"Advanced options","text":"","category":"section"},{"location":"AdvancedOptions/","page":"Advanced Options","title":"Advanced Options","text":"For most cases you only need to adjust the Gaussian range parameters nmax, r1, rnmax, (and additionally Nmax, R1, RNmax for three-body systems) in the numerical parameters. If you struggle to reach convergence or have other issues, changing the advanced parameters can help:","category":"page"},{"location":"AdvancedOptions/","page":"Advanced Options","title":"Advanced Options","text":"theta_csm: The complex rotation angle in degrees. Due to the Gaussian basis functions, this is limited to a maximum of 45°. If you deal with broad, or just-above-threshold resonances, you might need a larger complex rotation angle to uncover the resonance. For very broad resonances, it might however be practically impossible to resolve it numerically. If you need more precision for narrow resonances, reduce the complex rotation angle.\nomega_cr: Frequency of the complex-ranged Gaussian basis functions. A larger value corresponds to faster oscillations. Experience showed that typically a value between 0.5 and 2.0 is advisable, default is at 0.9.\nthreshold: Cut-off below which eigenvalues of the norm-overlap are discarded when solving the generalized eigenvalue problem. If you experience unphysical, very large negative eigenvalues, try increasing the value of threshold. However, the overall resolution of your calculation will suffer accordingly. The underlying reason is that the non-orthogonal basis becomes almost degenerate and the generalized eigenvalue problem becomes ill-defined. A better solution is in most cases to ensure a larger difference between r1 and rnmax (and/or between R1 and RNmax).\nkmax_threshold: Number of effective Gaussian ranges used for interpolation of the interaction matrix elements. If your interaction potential features many details, try increasing this number.\nlmin, lmax: Make sure you allow for appropriate angular momenta of your subsystems for the desired total angular momentum and parity. Including large values (4 and above) can quickly blow-up your calcuational cost in both time and memory (especially for three-body systems).\nmu0, c_shoulder: Parameters for treating general central potentials in the ISGL method. Default values are 0.08 and 1.6, provided by the original authors of the method. Change only if you are desperate.\nlarge number of allocations/memory usage: This is due to numerical integration of the matrix elements via QuadGK. If your interaction potential allows for an analytic treatment, consider implementing it yourself and/or file an issue. Currently, only Gaussian interactions are treated analytically, but more will be added in the future.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FewBodyToolkit\nGEM2B\nGEM3B1D\nISGL","category":"page"},{"location":"api/#FewBodyToolkit","page":"API","title":"FewBodyToolkit","text":"","category":"section"},{"location":"api/#FewBodyToolkit.CentralPotential","page":"API","title":"FewBodyToolkit.CentralPotential","text":"CentralPotential(f::Function)\n\nA concrete implementation of PotentialFunction that represents a central potential. It takes a function f that defines the potential as a function of the radial distance r.\n\n\n\n\n\n","category":"type"},{"location":"api/#FewBodyToolkit.ContactPotential1D","page":"API","title":"FewBodyToolkit.ContactPotential1D","text":"ContactPotential1D(v0::Float64, z0::Float64)\n\nA concrete implementation of PotentialFunction that represents a 1D Contact (Dirac) potential:\n\nV(z) = v_0  delta(z - z_0)\n\nwhere z is the 1D coordinate.\n\nArguments:\n\nv0::Float64: The strength of the potential.\nz0::Float64: The position of the delta function.\n\n\n\n\n\n","category":"type"},{"location":"api/#FewBodyToolkit.ContactPotential1D-Tuple{Float64}","page":"API","title":"FewBodyToolkit.ContactPotential1D","text":"function (gp::ContactPotential1D)(z::Float64)\n\nEvaluates the contact potential at a given 1D coordinate z.\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.GaussianPotential","page":"API","title":"FewBodyToolkit.GaussianPotential","text":"GaussianPotential(v0::Float64, mu_g::Float64)\n\nA concrete implementation of PotentialFunction that represents a Gaussian potential:\n\nV(r) = v_0  e^-mu_g r^2\n\nwhere r is the radial distance.\n\nArguments:\n\nv0::Float64: The strength of the potential.\nmu_g::Float64: The width parameter of the Gaussian potential.\n\n\n\n\n\n","category":"type"},{"location":"api/#FewBodyToolkit.GaussianPotential-Tuple{Any}","page":"API","title":"FewBodyToolkit.GaussianPotential","text":"function (gp::GaussianPotential)(r::Float64)\n\nEvaluates the Gaussian potential at a given radial distance r.\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.PotentialFunction","page":"API","title":"FewBodyToolkit.PotentialFunction","text":"PotentialFunction\n\nAbstract type for potential functions used in few-body calculations. This type serves as a parent type for more specific potential implementations\n\n\n\n\n\n","category":"type"},{"location":"api/#GEM2B","page":"API","title":"GEM2B","text":"","category":"section"},{"location":"api/#FewBodyToolkit.GEM2B.PreallocStruct2B","page":"API","title":"FewBodyToolkit.GEM2B.PreallocStruct2B","text":"PreallocStruct2B{TTV, TS, TE}\n\nA structure that holds preallocated arrays for the GEM-2B solver, used to store basis parameters, matrices, and results for two-body calculations.\n\nFields\n\nnu_arr::Vector{TTV}: Array of nonlinear variational parameters (basis exponents).\nS::Matrix{TS}: Overlap matrix between basis functions.\nT::Matrix{TTV}: Kinetic energy matrix.\nV::Matrix{TTV}: Potential energy matrix.\nenergies::Vector{TE}: Array to store computed eigenvalues (energies).\nwavefunctions::Matrix{TTV}: Matrix to store eigenvectors (wavefunctions).\n\nType Parameters\n\nTTV: Element type for kinetic, potential, and basis parameter arrays (e.g., Float64 or ComplexF64).\nTS: Element type for the overlap matrix (e.g., Float64 or ComplexF64).\nTE: Element type for the energies array (e.g., Float64 or ComplexF64).\n\nDescription\n\nThis struct is designed to minimize memory allocations and improve performance by reusing arrays during repeated GEM-2B calculations. The types and sizes of the arrays are determined by the numerical parameters and whether complex rotation or complex scaling is used.\n\nKeyword arguments\n\nnum_params: A named tuple containing numerical parameters, including the maximum number of basis functions (nmax).\ncr_bool: Boolean indicating whether complex range basis functions are used (1 for true, 0 for false).\ncsm_bool: Boolean indicating whether complex scaling is used (1 for true, 0 for false).\n\nExample\n\nPreallocStruct2B(num_params, cr_bool=0, csm_bool=0) # for real basis functions and no complex scaling\nPreallocStruct2B(num_params, cr_bool=1, csm_bool=0) # for complex range basis functions and no complex scaling\nPreallocStruct2B(num_params, cr_bool=0, csm_bool=1) # for real basis functions with complex scaling\n\n\n\n\n\n","category":"type"},{"location":"api/#FewBodyToolkit.GEM2B.GEM2B_solve-Tuple{Any, Any}","page":"API","title":"FewBodyToolkit.GEM2B.GEM2B_solve","text":"GEM2B_solve(phys_params, num_params; wf_bool=0, cr_bool=0, csm_bool=0)\n\nSolves two-body quantum mechanical problems using the Gaussian Expansion Method (GEM).\n\nArguments\n\nphys_params: Physical parameters describing the two-body system:\nhbar::Float64: reduced Planck constant \nmur::Float64: reduced mass \nvint_arr=Vector{Any}: a vector of interactions\nlmax::Int: power of r^lmax in the basis functions; indicator for the angular momentum in 3D\ndim::Int: the spatial dimension\nnum_params: Numerical parameters struct containing information on the set of basis functions:\ngem_params::NamedTuple: (number of basis functions, smallest and largest range parameters).\ntheta_csm::Float64: Complex scaling angle (in radians) for the Complex Scaling Method.\nomega_cr::Float64: Parameter controlling the frequency for complex-ranged basis functions.\nthreshold::Float64: Numerical threshold generalized eigenvalue solver.\n\nKeywords\n\nwf_bool=0: Whether to return wavefunctions (0: energies only, 1: energies and wavefunctions)\ncr_bool=0: Whether to use complex rotation method (0: no, 1: yes)\ncsm_bool=0: Whether to use complex scaling method (0: no, 1: yes)\n\nReturns\n\nenergies: Array of energy eigenvalues\nwavefunctions: (Optional) Array of eigenvectors if wf_bool=1\n\nExample\n\nphys_params = make_phys_params2B(hbar=1.0, mur=1.0, vint_arr=[GaussianPotential(-1.0, 0.5)], lmax=0, dim=3)\nnum_params = make_num_params2B(gem_params=(nmax=5, r1=1.0, rnmax=10.0), omega_cr=0.5, theta_csm=0.0, threshold=1e-10)\nenergies = GEM2B_solve(phys_params, num_params; wf_bool=0, cr_bool=0, csm_bool=0)\n# or with wavefunctions:\nenergies, wavefunctions = GEM2B_solve(phys_params, num_params; wf_bool=1)\n# Note: The function can handle 1D, 2D, or 3D problems based on the `dim` parameter in `phys_params`.\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.GEM2B.GEM_Optim_2B-Tuple{Any, Any, Any}","page":"API","title":"FewBodyToolkit.GEM2B.GEM_Optim_2B","text":"GEM_Optim_2B(phys_params, num_params, stateindex; cr_bool=0, g_tol=1e-9)\n\nOptimize the ranges used in the Gaussian Expansion Method (GEM) for a specific 2-body state.\n\nArguments\n\nphys_params::NamedTuple: Physical parameters such as hbar, mur, vint_arr, lmax, lmin, and dim.\nnum_params::NamedTuple: Numerical parameters such as gem_params, omega_cr, theta_csm, and threshold.\nstateindex::Int: An integer specifying the index of the state to optimize (e.g., 1 for the ground state).\n\nKeyword Arguments\n\ncr_bool::Int=0: Indicates whether to use complex rotation.\ng_tol::Float64=1e-9: A value specifying the tolerance for the optimizer.\n\nReturns\n\nA vector containing:\nOptimized GEM parameters: [r1, rnmax].\nThe energy value of the optimized state.\n\nExample\n\nr1opt,rnmaxopt,energy = GEM_Optim_2B(phys_params, num_params, 1) # optimize for the ground state\nr1opt,rnmaxopt,energy = GEM_Optim_2B(phys_params, num_params, 3; cr_bool = 1) # optimize for the third state (2nd excited) using complex-ranged basis functions\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.GEM2B.make_num_params2B-Tuple{}","page":"API","title":"FewBodyToolkit.GEM2B.make_num_params2B","text":"make_num_params2B(; gem_params=(nmax=5, r1=1.0, rnmax=10.0), theta_csm=0.0, omega_cr=0.9, threshold=1e-8)\n\nCreate and return a named tuple containing the numerical parameters for a two-body GEM calculation.\n\nKeyword arguments\n\ngem_params::NamedTuple = (nmax=5, r1=1.0, rnmax=10.0): Parameters for the Gaussian Expansion Method (number of basis functions, smallest and largest range parameters).\ntheta_csm::Float64 = 0.0: Complex scaling angle (in radians) for the Complex Scaling Method.\nomega_cr::Float64 = 0.9: Parameter controlling the frequency for complex-ranged basis functions.\nthreshold::Float64 = 1e-8: Numerical threshold generalized eigenvalue solver.\n\nReturns\n\nNamedTuple: Named tuple with the specified numerical parameters.\n\nExample\n\nmake_num_params2B(gem_params=(nmax=20, r1=0.1, rnmax=50.0)) # for a larger basis set\nmake_num_params2B(gem_params=(nmax=20, r1=0.1, rnmax=50.0), theta_csm = 10.0) # non-zero rotation angle for complex scaling method (CSM)\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.GEM2B.make_phys_params2B-Tuple{}","page":"API","title":"FewBodyToolkit.GEM2B.make_phys_params2B","text":"make_phys_params2B(; hbar=1.0, mur=1.0, vint_arr=[[GaussianPotential(-1.0, 1.0)]], lmin=0, lmax=0, dim=3)\n\nCreate and return a named tuple containing the physical parameters for a two-body system.\n\nKeyword arguments\n\nhbar::Float64 = 1.0: Reduced Planck constant used in calculations.\nmur::Float64 = 1.0: Reduced mass of the two-body system.\nvint_arr::Vector{Any} = [[GaussianPotential(-1.0, 1.0)]]: Array of interaction potentials or related parameters.\nlmin::Int = 0: Minimum orbital angular momentum quantum number.\nlmax::Int = 0: Maximum orbital angular momentum quantum number.\ndim::Int = 3: Spatial dimension of the system.\n\nReturns\n\nNamedTuple: Named tuple with the specified physical parameters.\n\nExample\n\nmake_phys_params2B(vint_arr=[GaussianPotential(-1.0, 0.5)], dim=1) # 1D system with Gaussian potential\nmake_phys_params2B(mur=0.5, vint_arr=[r -> -1/r], lmax=2)       # 3D Coulomb potential in d-wave (l=2) with reduced mass 0.5\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.GEM2B.v0GEMOptim-NTuple{4, Any}","page":"API","title":"FewBodyToolkit.GEM2B.v0GEMOptim","text":"v0GEMOptim(phys_params, num_params, stateindex, target_e2; cr_bool=0, rtol=1e-4, atol=10*eps(), g_tol=1e-9, output=false)\n\nFinds a value v0crit to globally scale the potential in order to achieve the target energy target_e2 for the state specified by stateindex. Additionally, performs intermediate optimization of Gaussian Expansion Method (GEM) parameters.\n\nArguments\n\nphys_params::NamedTuple: Physical parameters including hbar, mur, vint_arr, lmax, lmin, and dim.\nnum_params::NamedTuple: Numerical parameters including gem_params, omega_cr, theta_csm, and threshold.\nstateindex::Int: Index of the state to optimize, where 1 indicates the ground state.\ntarget_e2::Float64: Target energy value.\n\nKeyword Arguments\n\ncr_bool::Int: Use complex rotation (default: 0).\nrtol::Float64: Relative tolerance for energy convergence (default: 1e-4).\natol::Float64: Absolute tolerance for energy convergence (default: 10*eps()).\ng_tol::Float64: Tolerance for the optimizer (default: 1e-9).\noutput::Bool: If true, prints intermediate optimization results (default: false).\n\nReturns\n\nphys_params::NamedTuple: Updated physical parameters with optimized potential.\nnum_params::NamedTuple: Updated numerical parameters with optimized GEM ranges.\nv0crit::Float64: The value to scale the potential with, to achieve the target energy. This is not the overall value of v0 but rather a scaling factor for the potential.\n\nExample\n\nphys_params_scaled,num_params_optimized,scalingfactor = v0GEMOptim(phys_params, num_params, 1, -2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.GEM2B.wavefun_arr-NTuple{4, Any}","page":"API","title":"FewBodyToolkit.GEM2B.wavefun_arr","text":"wavefun_arr(r_arr, phys_params, num_params, wf_arr; cr_bool=0)\n\nCalculates the 2-body wavefunction at specified positions based on input parameters and coefficients.\n\nArguments\n\nr_arr::Vector{Float64}: Array of positions where the wavefunction is evaluated.\nphys_params::NamedTuple: Physical parameters, here we only need lmaxand dim\nnum_params::NamedTuple: Numerical parameters containing the information about the Gaussian ranges\nwf_arr::Vector: Eigenvector from the diagonalization routine. Can be complex-valued.\n\nKeyword Arguments\n\ncr_bool::Int=0: Determines whether to use complex-ranged Gaussians (1) or not (0). Defaults to 0.\n\nReturns\n\nVector{Float64}: The wavefunction values at the specified positions r_arr.\n\nExample\n\nwavefun_arr(0.0:0.1:10.0, phys_params, num_params, wf_arr; cr_bool=0)\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.GEM2B.wavefun_point-NTuple{5, Any}","page":"API","title":"FewBodyToolkit.GEM2B.wavefun_point","text":"wavefun_point(r, nu_arr, wf_arr, ll, dim)\n\nCompute the value of the 2-body wavefunction at a given position r.\n\nArguments\n\nr::Float64: The radial position where the wavefunction is evaluated.\nnu_arr::Vector: Array of Gaussian widths.\nwf_arr::Vector: Coefficients of the wavefunction for the given state.\nll::Int: Orbital angular momentum quantum number.\ndim::Int: Dimensionality of the system.\n\nReturns\n\nFloat64: The computed value of the wavefunction at the specified position r.\n\nExample\n\nnu_arr = [1.0, 0.0025]\nwf_arr = [0.8,0.6]\npsi_value = wavefun_point(1.0, nu_arr, wf_arr, 0, 3)\n\n\n\n\n\n","category":"method"},{"location":"api/#GEM3B1D","page":"API","title":"GEM3B1D","text":"","category":"section"},{"location":"api/#FewBodyToolkit.GEM3B1D.GEM3B1D_solve-Tuple{Any, Any}","page":"API","title":"FewBodyToolkit.GEM3B1D.GEM3B1D_solve","text":"GEM3B1D_solve(phys_params, num_params; wf_bool=0, csm_bool=0, observ_params=(;stateindices=[],centobs_arr=[[],[],[]],R2_arr=[0,0,0]))\n\nSolves the 1D three-body problem using the Gaussian Expansion Method (GEM).\n\nArguments\n\nphys_params: Physical parameters for the three-body system (e.g., masses, interaction potentials, etc.).\nnum_params: Numerical parameters for the GEM calculation (e.g., basis size, grid parameters, etc.).\nwf_bool: (optional) If 1, also returns wavefunction-related observables. Default is 0.\ncsm_bool: (optional) If 1, uses complex scaling method. Default is 0.\nobserv_params: (optional) Parameters for observable calculations. Currently not supported for 1D.\n\nReturns\n\nIf wf_bool == 0: Returns an array of computed energies.\nIf wf_bool == 1: Returns a tuple (energies, wavefunctions).\n\nExample\n\nphys_params = make_phys_params3B1D()\nnum_params = make_num_params3B1D()\nenergies = GEM3B3D_solve(phys_params, num_params) #solving with default parameters: three particles with the same mass and gaussian interaction\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.GEM3B1D.make_num_params3B1D-Tuple{}","page":"API","title":"FewBodyToolkit.GEM3B1D.make_num_params3B1D","text":"make_num_params3B1D(;lmin=0, Lmin=0, lmax=0, Lmax=0, gem_params=(nmax=5, r1=1.0, rnmax=10.0, Nmax=5, R1=1.0, RNmax=10.0), theta_csm=0.0, omega_cr=0.9, kmax_interpol=1000, threshold=10^-8)\n\nCreate and return a named tuple containing the numerical parameters for a three-body GEM calculation in 1D.\n\nKeyword arguments\n\nlmin::Int = 0: Minimum power r^l used in the basis functions of the r Jacobi coordinate.\t\nLmin::Int = 0: Minimum power r^L used in the basis functions of the R Jacobi coordinate.\nlmax::Int = 0: Maximum power r^l used in the basis functions of the r Jacobi coordinate.\nLmax::Int = 0: Maximum power r^L used in the basis functions of the R Jacobi coordinate.\ngem_params::NamedTuple = (nmax=5, r1=1.0, rnmax=10.0, Nmax=5, R1=1.0, RNmax=10.0): Parameters for the Gaussian Expansion Method (number of basis functions, smallest and largest range parameters for both Jacobi coordinates).\ntheta_csm::Float64 = 0.0: Complex scaling angle (in degrees) for the Complex Scaling Method.\nomega_cr::Float64 = 0.9: Parameter controlling the frequency for complex-ranged basis functions. Currently unsupported.\nkmax_interpol::Int = 1000: Number of numerical integration with effective Gaussian ranges used for interpolation.\nthreshold::Float64 = 1e-8: Numerical threshold for the generalized eigenvalue solver.\n\nReturns\n\nNamedTuple: Named tuple with the specified numerical parameters.\n\nExample\n\nmake_num_params3B1D() # for the default basis set\nmake_num_params3B1D(gem_params=(nmax=10, r1=0.5, rnmax=20.0, Nmax=15, R1=1.0, RNmax=100.0), theta_csm=10.0) for a larger basis set and non-zero rotation angle for complex scaling method\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.GEM3B1D.make_phys_params3B1D-Tuple{}","page":"API","title":"FewBodyToolkit.GEM3B1D.make_phys_params3B1D","text":"make_phys_params3B1D(; hbar=1.0, mass_arr=[1.0,1.0,1.0], svals=[\"x\",\"y\",\"z\"], vint_arr=[[GaussianPotential(-1.0, 1.0)],[GaussianPotential(-1.0, 1.0)],[GaussianPotential(-1.0, 1.0)]], parity=+1)\n\nCreate and return a named tuple containing the physical parameters for a three-body system in 1D.\n\nKeyword arguments\n\nhbar::Float64 = 1.0: Reduced Planck constant used in calculations.\nmass_arr::Vector{Float64} = [1.0,1.0,1.0]: 3-element vector containing the masses of the three particles.\nsvals::Vector{String} = [\"x\",\"y\",\"z\"]: 3-element vector containing the types of particles, used for automatic (anti-)symmetrization. \"b\" (\"f\") for identical bosons (fermions). Either 0, 2, or 3 identical particles.\nvint_arr::Vector{Vector{Any}} = [[GaussianPotential(-1.0, 1.0)],[GaussianPotential(-1.0, 1.0)],[GaussianPotential(-1.0, 1.0)]]: Vector of Vector of interaction potentials for each pair of particles: [[v231,v232,...],[v311,v312,...],[v121,v122,...]].\nparity::Int = 1: Parity parity=(-1)^(l+L) of the wave function. Possible values: +1,-1 for positive/negative parity, 0 for parity-violating potentials.\n\nReturns\n\nNamedTuple: Named tuple with the specified physical parameters.\n\nExample\n\nmake_phys_params3B1D() # default: system of three different particles with the same mass and Gaussian interactions\nmake_phys_params3B1D(mass_arr=[1.0,10.0,20.0], svals=[\"i\",\"j\",\"k\"], vint_arr=[[v23],[v31],[v12_1,v12_2]]) # system of three different particles with interactions v23 (between particles 2 and 3), v31 (between particles 3 and 1), and v12_1, v12_2 (between particles 1 and 2). The interactions need to be defined before this call.\n\n\n\n\n\n","category":"method"},{"location":"api/#ISGL","page":"API","title":"ISGL","text":"","category":"section"},{"location":"api/#FewBodyToolkit.ISGL.ISGL_solve-Tuple{Any, Any}","page":"API","title":"FewBodyToolkit.ISGL.ISGL_solve","text":"ISGL_solve(phys_params, num_params; wf_bool=0, csm_bool=0, observ_params=(;stateindices=[],centobs_arr=[[],[],[]],R2_arr=[0,0,0]))\n\nSolves the 3D three-body problem using the Gaussian Expansion Method (GEM).\n\nArguments\n\nphys_params: Physical parameters for the three-body system (e.g., masses, interaction potentials, etc.).\nnum_params: Numerical parameters for the GEM calculation (e.g., basis size, grid parameters, etc.).\nwf_bool: (optional) If 1, also returns wavefunction-related observables. Default is 0.\ncsm_bool: (optional) If 1, uses complex scaling method. Default is 0.\nobserv_params: (optional) Parameters for observable calculations.\nstateindices: Indices of states for which observables are calculated.\ncentobs_arr: Array of central (only dependent on r; must be defined as functions) observables, for each Jacobi set (similar to vint_arr in phys_params).\nR2_arr: Array which indicates whether the observable langle R^2 rangle should be calculated (1) for any of the three Jacobi sets, or not (0).\n\nReturns\n\nIf wf_bool == 0: Returns an array of computed energies.\nIf wf_bool == 1: Returns a tuple (energies, wavefunctions, centobs_output, R2_output).\nenergies: Vector of computed energies.\nwavefunctions: Matrix of eigenvectors (column-wise) which contain the coefficients of the basis functions.\ncentobs_output: Mean values of central observables for the specified states. The first dimension corresponds to the Jacobi sets, the second to the observables, and the third to the states.\nR2_output: Mean squared radii for the R-coordinate. Rows corresond to the Jacobi sets, columns to the states.\n\nExample\n\nphys_params = make_phys_params3B3D()\nnum_params = make_num_params3B3D()\nenergies = ISGL_solve(phys_params, num_params) #solving with default parameters: three particles with the same mass and gaussian interaction\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.ISGL.csmgaussopt-Tuple{Vector{Vector{Tuple{Float64, Float64}}}, Integer, Real}","page":"API","title":"FewBodyToolkit.ISGL.csmgaussopt","text":"csmgaussopt(gaussopt, csm_bool, theta_csm)\n\nIf csm_bool == 1, returns a new Vector{Vector{Tuple{Float64,ComplexF64}}} where each mu has been scaled by exp(2im * theta_csm * pi/180). Otherwise returns the original gaussopt unchanged.\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.ISGL.make_num_params3B3D-Tuple{}","page":"API","title":"FewBodyToolkit.ISGL.make_num_params3B3D","text":"make_num_params3B3D(;lmin=0, Lmin=0, lmax=0, Lmax=0, gem_params=(nmax=10, r1=0.2, rnmax=10.0, Nmax=10, R1=0.2, RNmax=20.0), theta_csm=0.0, omega_cr=0.9, mu0=0.08, c_shoulder=1.6, kmax_interpol=1000, threshold=10^-8)\n\nCreate and return a named tuple containing the numerical parameters for a three-body GEM calculation in 3D.\n\nKeyword arguments\n\nlmin::Int = 0: Minimum power r^l used in the basis functions of the r Jacobi coordinate.\t\nLmin::Int = 0: Minimum power r^L used in the basis functions of the R Jacobi coordinate.\nlmax::Int = 0: Maximum power r^l used in the basis functions of the r Jacobi coordinate.\nLmax::Int = 0: Maximum power r^L used in the basis functions of the R Jacobi coordinate.\ngem_params::NamedTuple = (nmax=5, r1=1.0, rnmax=10.0, Nmax=5, R1=1.0, RNmax=10.0): Parameters for the Gaussian Expansion Method (number of basis functions, smallest and largest range parameters for both Jacobi coordinates).\ntheta_csm::Float64 = 0.0: Complex scaling angle (in degrees) for the Complex Scaling Method.\nomega_cr::Float64 = 0.9: Parameter controlling the frequency for complex-ranged basis functions. Currently unsupported.\nmu0::Float64 = 0.08: Parameter (prefactor) for the ISGL method.\nc_shoulder::Float64 = 1.6: Parameter (base) for the ISGL method.\nkmax_interpol::Int = 1000: Number of numerical integration with effective Gaussian ranges used for interpolation.\nthreshold::Float64 = 1e-8: Numerical threshold for the generalized eigenvalue solver.\n\nReturns\n\nNamedTuple: Named tuple with the specified numerical parameters.\n\nExample\n\nmake_num_params3B3D() # for the default basis set\nmake_num_params3B3D(gem_params=(nmax=10, r1=0.5, rnmax=20.0, Nmax=15, R1=1.0, RNmax=100.0), kmax_interpol=5000) for a larger basis set, and a finer interpolation grid for matrix-element calculations of interactions with many features.\n\n\n\n\n\n","category":"method"},{"location":"api/#FewBodyToolkit.ISGL.make_phys_params3B3D-Tuple{}","page":"API","title":"FewBodyToolkit.ISGL.make_phys_params3B3D","text":"make_phys_params3B3D(; hbar=1.0, mass_arr=[1.0,1.0,1.0], svals=[\"x\",\"y\",\"z\"], vint_arr=[[GaussianPotential(-1.0, 1.0)],[GaussianPotential(-1.0, 1.0)],[GaussianPotential(-1.0, 1.0)]], J_tot=0, parity=+1, spin_arr=[0,0,0])\n\nCreate and return a named tuple containing the physical parameters for a three-body system in 3D.\n\nKeyword arguments\n\nhbar::Float64 = 1.0: Reduced Planck constant used in calculations.\nmass_arr::Vector{Float64} = [1.0,1.0,1.0]: 3-element vector containing the masses of the three particles.\nsvals::Vector{String} = [\"x\",\"y\",\"z\"]: 3-element vector containing the types of particles, used for automatic (anti-)symmetrization. \"b\" (\"f\") for identical bosons (fermions). Either 0, 2, or 3 identical particles.\nvint_arr::Vector{Vector{Any}} = [[GaussianPotential(-1.0, 1.0)],[GaussianPotential(-1.0, 1.0)],[GaussianPotential(-1.0, 1.0)]]: Vector of Vector of interaction potentials for each pair of particles: [[v231,v232,...],[v311,v312,...],[v121,v122,...]].\nJ_tot::Int = 0: Total angular momentum of the system. Can take on half-integer values when spins are involved.\nparity::Int = 1: Parity parity=(-1)^(l+L) of the wave function. Possible values: +1,-1 for positive/negative parity, 0 for parity-violating potentials.\nspin_arr::Vector{Float64} = [0,0,0]: 3-element vector containing the spins [z1,z2,z_3] of the three particles. Used for automatic (anti-)symmetrization.\n\nReturns\n\nNamedTuple: Named tuple with the specified physical parameters.\n\nExample\n\nmake_phys_params3B3D() # default: system of three different particles with the same mass and Gaussian interactions\nmake_phys_params3B3D(mass_arr=[10.0,10.0,20.0], svals=[\"i\",\"j\",\"k\"], vint_arr=[[v23],[v31],[v12_1,v12_2]], J_tot=3/2, spin_arr=[1/2,1/2,1/2],parity=-1, lmax=1, Lmax=1) # system of three different particles with half-integer spin, and interactions v23 (between particles 2 and 3), v31 (between particles 3 and 1), and v12_1, v12_2 (between particles 1 and 2). The interactions need to be defined before this call.\n\n\n\n\n\n","category":"method"},{"location":"BasisFunctions/#Gaussian-Basis-Functions","page":"Basis Functions","title":"Gaussian Basis Functions","text":"","category":"section"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"This page provides an overview of the centered Gaussian basis functions used for 2‑ and 3‑body quantum calculations in the package. It covers standard real-range Gaussians, an extension to complex-ranged Gaussians, and the methods used for higher angular momenta in three-body systems. A more extensive introduction, however limited to 3D systems, can be found in Ref. [1].","category":"page"},{"location":"BasisFunctions/#Two-Body","page":"Basis Functions","title":"Two-Body","text":"","category":"section"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"The module GEM2B provides a solver for two-body systems described by the Schrödinger equation","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"left-frachbar^22mu nabla_vecr^2 + V(vecr) rightphi(vecr) = E phi(vecr)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"The Laplacian should be interpreted according to the dimensionality (1D, 2D, 3D).","category":"page"},{"location":"BasisFunctions/#Centered,-real-range-Gaussian-basis-functions","page":"Basis Functions","title":"Centered, real-range Gaussian basis functions","text":"","category":"section"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"The Gaussian expansion method is based on expanding an unknown state into a set","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"phi(r) = sum_alpha c_alpha phi_alpha(r)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"of Gaussian basis functions phi_alpha . They are originally defined in 3D as","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"phi_alpha^(3D)(r) = N_nl r^l e^-nu_n r^2 Y_lm(thetaphi)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"with the multi-index alpha = nl. This definition can be extended to 1D and 2D systems by considering (the normalization depends on the dimensionality)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"phi_alpha^(1D)(r) = N_nl r^l e^-nu_n r^2 \nphi_alpha^(2D)(r) = N_nl r^l e^-nu_n r^2 e^imphi","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"In 3D, the index l denotes the angular momentum. In 1D, we can associate even and odd values of it to the parity or symmetry of a two-body state. The index n is associated with the Gaussian ranges nu_n which are chosen in a geometric progression","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"nu_n = 1r_n^2 qquad r_n = r_1 a^n-1 qquad a = left(fracr_n_maxr_1 right)^1(n_max-1)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"defined by the parameters nmax, r1, rnmax. This choice allows for a large function space, while keeping a low number of numerical parameters. The series of ranges is created in the function buildnu.","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"Using Gaussian basis functions allows to treat many steps fully analytically, and is especially useful for 3-body calculations. However, they are not orthogonal which implies that finding the solution to a few-body problem requires solving a generalized eigenvalue problem, instead of a standard one. For this, we provide the function eigen2step, which is similar to eigen(A,B), but it removes eigenvalues of B below a certain threshold, to cure a possibly ill-posed problem. Such a situation can arise if a set of too many basis functions with similar ranges is used.","category":"page"},{"location":"BasisFunctions/#Complex-ranged-Gaussians","page":"Basis Functions","title":"Complex-ranged Gaussians","text":"","category":"section"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"For oscillatory states, e.g. highly-excited states or metastable resonant states, it can be difficult to capture their details with standard Gaussians basis functions. A simple extension suggested in Ref. [1] are complex-ranged Gaussians which are obtained from the standard real-ranged ones by the transformation","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"nu to nu (1 pm iomega)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"This allows reusing the same code structure as for real-ranged Gaussians. Note that to ensure a real wave function, always the pair of both complex shifts is used, and hence the number of basis functions is twice the one defined in num_params. Complex-ranged Gaussians can be used with the optional keyword argument cr_bool = 1 when calling the solver.","category":"page"},{"location":"BasisFunctions/#Three-Body","page":"Basis Functions","title":"Three-Body","text":"","category":"section"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"The modules GEM3B1D, and ISGL provide a solver for three-body systems described by the Schrödinger equation","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"left -frachbar^22mu_ij nabla_vecr_k^2 - frachbar^22mu_k nabla_vecR_k^2 + V_12(vecr_12) + V_23(vecr_23) + V_31(vecr_31) right Psi(vecr_kvecR_k) = E Psi(vecr_kvecR_k)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"with the reduced masses mu_ij = (m_i m_j)(m_i + m_j)), and mu_k = (m_k (m_i+m_j))(m_i+m_j+m_k). The Laplacians should be interpreted accordingly to the dimensionality (1D, 3D). For demonstrational purposes, this equation is written in one specific Jacobi set, defined by assigning ijk to the particles 123. The solvers employ a combination of up to three Jacobi sets at once. The required number is determined automatically.","category":"page"},{"location":"BasisFunctions/#Jacobi-Coordinates-and-Faddeev-Components","page":"Basis Functions","title":"Jacobi Coordinates and Faddeev Components","text":"","category":"section"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"(Image: Jacobi coordinate sets)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"Figure 1: Three sets of Jacobi coordinates for a three-body system.","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"For three-body systems we employ Jacobi coordinates. This allows to describe the full system in its center-of-mass frame by two relative coordinates. However, there are three equivalent sets of these coordinates, related to the three different partitions of three particles into a pair of two, and a single one, see Fig. 1. In few-body physics it is therefore common to decompose any given three-body state into a sum","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"Psi(vecrvecR) = Psi^(1)(vecr_1vecR_1) + Psi^(2)(vecr_2vecR_2) + Psi^(3)(vecr_3vecR_3)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"of Faddeev components Psi^(i) (sometimes called rearrangement channels), each described in a different Jacobi set vecr_ivecR_i. In case some particles do not interact, or two or more are identical, the number of Faddeev components can be reduced. The code does this automatically.","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"Each component is then expanded into a set","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"Psi^(i)(vecr_ivecR_i) = sum_alpha=1^alpha_max A_alpha psi_alpha^(i)(vecr_ivecR_i)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"of basis functions psi_alpha^(i) which itself are composed of products of two functions","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"psi_alpha^(i)(vecr_ivecR_i) = phi_alpha(vecr_i) Phi_alpha(vecR_i)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"These functions are each defined as in the two-body case","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"phi_alpha(vecr) = N_lm r^l e^-nu_n r^2 Y_lm(hatr)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"Phi_alpha(vecR) = N_LM R^L e^-lambda_N R^2 Y_LM(hatR)","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"where now alpha = nlNL. For 2D and 1D systems, the spherical harmonics are simply replaced by e^i m varphi or 1, respectively. The basis is automatically constructed based on the inputs nmax,r1,rnmax,Nmax,R1,RNmax from gem_params in the input num_params.","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"The decomposition into different Faddeev components requires that we have to compute matrix elements of the form","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"langle Psi^(a)  hatO^(c) Psi^(b)rangle","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"with basis functions and operators in possibly different Jacobi sets abc. Owing to the Gaussian form, this can be done readily for s-wave states, since the Gaussian form is preserved when transforming from one set to another.","category":"page"},{"location":"BasisFunctions/#Higher-angular-momenta-via-infinitesimally-shifted-Gaussian-lobe-(ISGL)-functions","page":"Basis Functions","title":"Higher angular momenta via infinitesimally shifted Gaussian lobe (ISGL) functions","text":"","category":"section"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"If higher angular momenta are required, the transformation between different Jacobi sets quickly becomes laborious due to the presence of multiple spherical harmonics. To avoid this, the code makes use of so-called infinitesimally shifted Gaussian basis functions, to express the spherical harmonics in terms of several Gaussians with infinitesimal shift. This shift is treated analytically before computing the matrix elements. More details on this type of basis functions can be found in the review article [1]. We note that this treatment is only required in 3D. In 1D, matrix elements of different Jacobi sets can be computed more easily. Hence, we have two separate modules, GEM3B1D for 1D, and ISGL for 3D. Three-body systems in 2D are currently not supported.","category":"page"},{"location":"BasisFunctions/#Page-references","page":"Basis Functions","title":"Page references","text":"","category":"section"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"E. Hiyama, Y. Kino and M. Kamimura. Gaussian Expansion Method for Few-Body Systems. Prog. Part. Nucl. Phys. 51, 223–307 (2003).\n\n\n\n","category":"page"},{"location":"BasisFunctions/","page":"Basis Functions","title":"Basis Functions","text":"See also the full bibliography for further references cited throughout this documentation.","category":"page"},{"location":"example2D/#2D-Example:-Two-particles-with-Harmonic-oscillator-interaction","page":"2D Example","title":"2D Example: Two particles with Harmonic oscillator interaction","text":"","category":"section"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"This example demonstrates how to use the FewBodyToolkit.jl package to compute bound states for two particles in 2D. Here we use the harmonic oscillator, since it has analytic solutions. In relative coordinates, this system is equivalent to a single particle in a potential. It is governed by the following Schrödinger equation (we set the magnetic quantum number m = 0, and hbar = 1) \\[ -\\frac{1}{2 \\mu} \\left[\\frac{d^2}{dr^2} + \\frac{1}{r} \\frac{d}{dr} \\right] \\psi + V(r)\\psi = E\\psi \\] with the Harmonic oscillator potential \\[ V(r) = -\\frac{1}{2} \\mu \\omega^2 r^2. \\]","category":"page"},{"location":"example2D/#Setup","page":"2D Example","title":"Setup","text":"","category":"section"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"using Printf, Interpolations, FewBodyToolkit","category":"page"},{"location":"example2D/#Input-parameters","page":"2D Example","title":"Input parameters","text":"","category":"section"},{"location":"example2D/#Physical-parameters","page":"2D Example","title":"Physical parameters","text":"","category":"section"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"mass_arr=[1.0,10.0] # finite masses of the two particles\nmur = 1/(1/mass_arr[1]+1/mass_arr[2]) # reduced mass\nomega = 0.5\n\nfunction v_ho(r)\n    return 0.5*mur*omega^2*r^2\nend;\nnothing #hide","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"We define the physical parameters as a NamedTuple which carries the information about the Hamiltonian.","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"phys_params = make_phys_params2B(;mur,vint_arr=[v_ho],dim=2)","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"By leaving out the optional parameters, we use the defaults:","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"lmin = lmax = 0: minimum and maximum angular momentum\nhbar = 1.0: when working in dimensionless units","category":"page"},{"location":"example2D/#Numerical-parameters","page":"2D Example","title":"Numerical parameters","text":"","category":"section"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"nmax=14 # number of Gaussian basis functions\nr1=0.5;rnmax=10.0;\ngem_params = (;nmax,r1,rnmax);\nnothing #hide","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"We define the numerical parameters as a NamedTuple:","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"num_params = make_num_params2B(;gem_params,threshold=10^-8)","category":"page"},{"location":"example2D/#1.-Numerical-solution","page":"2D Example","title":"1. Numerical solution","text":"","category":"section"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"We solve the two-body system by calling GEM2B_solve.","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"energies = GEM2B.GEM2B_solve(phys_params,num_params);\nnothing #hide","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"The Harmonic Oscillator has infinitely many eigenvalues. For the radially symmetric states (m = 0) their energies are given by \\[ E_n = \\omega (2n+1) \\]","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"energies_exact = ([2*i for i=0:15] .+ 1) .*omega\n\nprintln(\"1. Numerical solution of the 2D problem:\")\nsimax=10;\ncomparison(energies, energies_exact, simax)","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"Especially for the first few states, the numerical energies are already reasonably close to the exact energies.","category":"page"},{"location":"example2D/#2.-Optimization-of-basis-parameters","page":"2D Example","title":"2. Optimization of basis parameters","text":"","category":"section"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"Still, we can try to improve the accuracy by optimizing the basis parameters for a given state indicated by stateindex.","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"stateindex = 6\nparams_opt = GEM2B.GEM_Optim_2B(phys_params, num_params, stateindex)\ngem_params_opt = (;nmax, r1 = params_opt[1], rnmax = params_opt[2])\nnum_params_opt = make_num_params2B(;gem_params=gem_params_opt)\nenergies_opt = GEM2B.GEM2B_solve(phys_params,num_params_opt)\n\nprintln(\"\\n2. Optimization of GEM parameters for E2[$stateindex]:\")\n@printf(\"%-15s %-15s %-15s %-15s %-15s\\n\", \"r1\", \"rnmax\", \"E2[$(stateindex-1)]\", \"E2[$stateindex]\", \"E2[$(stateindex+1)]\")\n\nprintln(\"Before optimization:\")\n@printf(\"%-15.6f %-15.6f %-15.6f %-15.6f %-15.6f\\n\", gem_params.r1, gem_params.rnmax, energies[stateindex-1], energies[stateindex], energies[stateindex+1])\n\nprintln(\"after optimization:\")\n@printf(\"%-15.6f %-15.6f %-15.6f %-15.6f %-15.6f\\n\", params_opt[1], params_opt[2], energies_opt[stateindex-1], energies_opt[stateindex], energies_opt[stateindex+1])","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"The optimized parameters yield not much of an iprovement, since the basis parameters were already quite good. We can improve the results by either using more basis functions, or by complex-ranged basis functions (see below)","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"comparison(energies_opt,energies_exact,simax; s1=\"Optimized\")","category":"page"},{"location":"example2D/#3.-Inverse-problem:-Tuning-the-potential-strength","page":"2D Example","title":"3. Inverse problem: Tuning the potential strength","text":"","category":"section"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"We can use v0GEMOptim to scale the interaction such that the state indicated by stateindex has a fixed energy target_e2. At the same time, the basis parameters are optimized for this state.","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"stateindex = 2; target_e2 = 3.0;\nprintln(\"\\n3. Scaling the potential such that E2[$stateindex] = $target_e2:\")\nphys_params_scaled,num_params_scaled,vscale = GEM2B.v0GEMOptim(phys_params,num_params_opt,stateindex,target_e2)\nenergies_v0 = GEM2B.GEM2B_solve(phys_params_scaled,num_params_scaled)\n\n@printf(\"%-15s %-15s %-15s %-15s %-15s\\n\", \"r1\", \"rnmax\", \"E2[$(stateindex-1)]\", \"E2[$stateindex]\", \"E2[$(stateindex+1)]\")\n@printf(\"%-15.6f %-15.6f %-15.6f %-15.6f %-15.6f\\n\", num_params_scaled.gem_params.r1, num_params_scaled.gem_params.rnmax, energies_v0[stateindex-1], energies_v0[stateindex], energies_v0[stateindex+1])","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"Here, we scale the potential such that the energy of the state with stateindex = 2 is equal to target_e2 = 3.0, i.e. twice its original value. Since the potential scales quadratically  with omega, we expect a scaling factor of 4.0.","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"println(\"vscale = $(round(vscale,digits=8)) should be approximately 4.0\")","category":"page"},{"location":"example2D/#4.-Using-complex-ranged-basis-functions","page":"2D Example","title":"4. Using complex-ranged basis functions","text":"","category":"section"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"We can also use complex-ranged basis functions, which are useful for more oscillatory bound states, i.e. highly excited states. Note that cr_bool=1 effectively employs twice the number of basis functions, hence for a fair comparison we choose nmaxC = nmax/2 = 7. Keep in mind that the optimal parameters for the complex-ranged basis functions are usually differnt. Hence, we optimize them separately.","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"nmaxC = 7\nr1C = 0.5; rnmaxC = 10.0;\ngem_paramsC = (;nmax=nmaxC,r1=r1C,rnmax=rnmaxC);\nnum_paramsC = make_num_params2B(;gem_params=gem_paramsC)\n\nstateindex = 6\nparams_opt = GEM2B.GEM_Optim_2B(phys_params, num_paramsC, stateindex; cr_bool = 1)\ngem_params_optC = (;nmax = nmaxC, r1 = params_opt[1], rnmax = params_opt[2])\nnum_params_optC = make_num_params2B(;gem_params=gem_params_optC)\nenergies_optC= GEM2B.GEM2B_solve(phys_params,num_params_optC; cr_bool = 1)\n\nprintln(\"\\n4. Using complex-ranged basis functions:\")\ncomparison(energies_optC, energies_exact, 14; s1=\"Complex-ranged\", s2=\"Exact\")","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"Using effectively 14 basis functions, we can reproduce the exact energies for the first 10 states with less than 1e-3 deviation, and even up to 14 states with reasonable accuracy.","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"","category":"page"},{"location":"example2D/","page":"2D Example","title":"2D Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example3D/#3D-Example:-Two-particles-with-Coulomb-interaction","page":"3D Example","title":"3D Example: Two particles with Coulomb interaction","text":"","category":"section"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"This example demonstrates how to use the FewBodyToolkit.jl package to compute bound states for two particles in 3D. Here we use the Coulomb interaction, since it has analytic solutions. In relative coordinates, this system is equivalent to a single particle in a potential. It is governed by the following Schrödinger equation (hbar mu=1) \\[ -\\frac{1}{2} \\frac{1}{r}\\frac{d^2}{dr^2}\\left( r\\psi \\right) + V(r)\\psi = E\\psi \\] with the Colomb potential \\[ V(r) = -\\frac{Z}{r}. \\]","category":"page"},{"location":"example3D/#Setup","page":"3D Example","title":"Setup","text":"","category":"section"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"using Printf, Interpolations, Plots, Antique, FewBodyToolkit","category":"page"},{"location":"example3D/#Input-parameters","page":"3D Example","title":"Input parameters","text":"","category":"section"},{"location":"example3D/#Physical-parameters","page":"3D Example","title":"Physical parameters","text":"","category":"section"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"mass_arr = [1.0, Inf] # array of masses of particles [m1,m2]\nmur = 1 / (1/mass_arr[1] + 1/mass_arr[2])\nZ = 1.0\n\nfunction v_coulomb(r)\n    return -Z/r\nend;\nnothing #hide","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"We define the physical parameters as a NamedTuple which carries the information about the Hamiltonian.","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"phys_params = make_phys_params2B(;vint_arr=[v_coulomb])","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"By leaving out the optional parameters, we use the defaults:","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"mur = 1.0: reduced mass\ndim = 3: dimension of the problem\nlmin = lmax = 0: minimum and maximum angular momentum\nhbar = 1.0: when working in dimensionless units","category":"page"},{"location":"example3D/#Numerical-parameters","page":"3D Example","title":"Numerical parameters","text":"","category":"section"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"nmax=10 # number of Gaussian basis functions\nr1=0.1;rnmax=30.0; # r1 and rnmax defining the widths of the basis functions\ngem_params = (;nmax,r1,rnmax);\nnothing #hide","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"We define the numerical parameters as a NamedTuple:","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"num_params = make_num_params2B(;gem_params)","category":"page"},{"location":"example3D/#1.-Numerical-solution","page":"3D Example","title":"1. Numerical solution","text":"","category":"section"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"We solve the two-body system by calling GEM2B_solve.","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"energies = GEM2B.GEM2B_solve(phys_params,num_params)","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"Number of bound states to consider:","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"simax = min(lastindex(energies),6); # max state index\nnothing #hide","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"The Coulomb potential has infinitely many bound states, whose energies can be found exactly. We can use the package Antique.jl to provide these energies.","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"CTB = Antique.CoulombTwoBody(m₁=mass_arr[1], m₂=mass_arr[2])\nenergies_exact = [Antique.E(CTB,n=i) for i=1:40]\n\nprintln(\"1. Numerical solution of the 3D problem:\")\ncomparison(energies,energies_exact,simax)","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"The numerical solutions are good only for the few lowest state. Also, we only find four bound states.","category":"page"},{"location":"example3D/#2.-Optimization-of-basis-parameters","page":"3D Example","title":"2. Optimization of basis parameters","text":"","category":"section"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"We can optimize the basis parameters for a specific state indicated by stateindex using GEM_Optim_2B.","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"stateindex = 6\nparams_opt = GEM2B.GEM_Optim_2B(phys_params, num_params, stateindex)\ngem_params_opt = (;nmax, r1 = params_opt[1], rnmax = params_opt[2])\nnum_params_opt = make_num_params2B(;gem_params=gem_params_opt)\nenergies_opt = GEM2B.GEM2B_solve(phys_params,num_params_opt)\n\nprintln(\"\\n2. Optimization of GEM parameters for E2[$stateindex]:\")\n@printf(\"%-15s %-15s %-15s %-15s %-15s\\n\", \"r1\", \"rnmax\", \"E2[$(stateindex-1)]\", \"E2[$stateindex]\", \"E2[$(stateindex+1)]\")\n\nprintln(\"Before optimization:\")\n@printf(\"%-15.6f %-15.6f %-15.6f %-15.6f %-15.6f\\n\", gem_params.r1, gem_params.rnmax, energies[stateindex-1], energies[stateindex], energies[stateindex+1])\n\nprintln(\"after optimization:\")\n@printf(\"%-15.6f %-15.6f %-15.6f %-15.6f %-15.6f\\n\", params_opt[1], params_opt[2], energies_opt[stateindex-1], energies_opt[stateindex], energies_opt[stateindex+1])","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"Optimizing the parameters for the 6th excited states finds more bound states, while loosing some accuracy for the lower states. Here, only more basis functions would help.","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"comparison(energies_opt,energies_exact,simax; s1=\"Optimized\")","category":"page"},{"location":"example3D/#3.-Example-with-many-basis-functions","page":"3D Example","title":"3. Example with many basis functions","text":"","category":"section"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"Highly accurate results can indeed be obtained by using a larger basis. For a two-body system this comes only at a moderate computational cost. Here, we reproduce table 2 of Ref. [1] with the following numerical parameters:","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"println(\"\\n3. Highly accurate solution using many basis functions:\")\nnp = make_num_params2B(;gem_params=(;nmax=80,r1=0.015,rnmax=2000.0),omega_cr=1.5,threshold=10^-11)\n@time energies_accurate = GEM2B.GEM2B_solve(phys_params,np;cr_bool=1) # ~3s on an average laptop\nnlist=[1,2,3,4,5,10,14,18,22,26,30,32,34,36,38,40]; # states shown in the article\ncomparison(energies_accurate,energies_exact,lastindex(nlist); s1=\"Numerical\", s2=\"Exact\",indexlist=nlist)","category":"page"},{"location":"example3D/#4.-Using-an-interpolated-interaction","page":"3D Example","title":"4. Using an interpolated interaction","text":"","category":"section"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"We can also create a potential from interpolated data. Since the Coulomb potential diverges at the origin, a relatively fine grid is required.","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"r_arr = 0.001:0.01:50.001\nv_arr = v_coulomb.(r_arr)\nv_interpol = cubic_spline_interpolation(r_arr,v_arr,extrapolation_bc=Line())\nv_int(r) = v_interpol(r); # we have to transform the interaction to an object of type \"function\"\nnothing #hide","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"As input to the solver we need to define new physical parameters with the interpolated interaction. Moreover, we use the optimized numerical parameters from the previous step.","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"phys_params_i = make_phys_params2B(;mur,vint_arr=[v_int],dim=3)\n\nprintln(\"\\n4. Numerical solution using an interpolated interaction:\")\nenergies_interpol = GEM2B.GEM2B_solve(phys_params_i,num_params_opt)\ncomparison(energies_interpol, energies_opt, simax;s1=\"Interpolated\", s2=\"Optimized\")","category":"page"},{"location":"example3D/#5.-Coupled-channel-problem","page":"3D Example","title":"5. Coupled-channel problem","text":"","category":"section"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"The package also supports coupled-channel problems via GEM2B_solveCC. In this case the interaction is not provided via phys_params","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"phys_paramsCC = make_phys_params2B(;vint_arr=[r->0.0])","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"but via extra arguments WCC: wfun on the diagonal; wfun2 for off-diagonal couplings, and DCC: derivative terms of order dor, and radial prefactors dfun (diagonal) and dfun2 (off-diagonal).","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"wfun(r) = v_coulomb(r);wfun2(r) = 0.05*exp(-r^2)\ndfun(r) = 0.0; dfun2(r) = 0.0\nWCC = [wfun wfun2; wfun2 wfun]\ndor = 1; #derivative-order\nDCC = reshape([ [dor, dfun], [dor, dfun2], [dor, dfun2], [dor, dfun] ], 2, 2)","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"As a test-case we use the coulomb interaction on the diagonal, and a weak repulsion on the off-diagonal. We don't consider any extra derivatives. Since the coupling is weak, we get approximately twofold degenerate eigenvalues, splitted around the original Coulomb results.","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"energiesCC = GEM2B.GEM2B_solveCC(phys_paramsCC, num_params_opt, WCC, DCC; diff_bool=0)\n\nenergies_exactCC = repeat(energies_exact, inner=(2,))\n\nprintln(\"\\n5. Coupled channel calculation:\")\ncomparison(energiesCC, energies_exactCC, simax; s1=\"Coupled-Channel\")","category":"page"},{"location":"example3D/#6.-Calculation-of-the-wave-function","page":"3D Example","title":"6. Calculation of the wave function","text":"","category":"section"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"Adding the optional argument wf_bool=1 to GEM2B_solve also computes and returns a matrix of eigenvectors (in each column). These eigenvectors contain the weights of the basis functions.","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"energiesw,wfs = GEM2B.GEM2B_solve(phys_params,num_params_opt;wf_bool=1,cr_bool=0);\nnothing #hide","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"We can use the functions GEM2B.wavefun_arr and GEM2B.wavefun_point to compute the wave function at a set of points or at a specific point, respectively. The information on the basis functions is provided via the optimized numerical parameters num_params_opt, the vector of Gaussian widths. We compare the numerical wave function with the exact solutions provided by Antique.jl and find very good agreement.","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"dr = 0.1\nr_arr = 0.0:dr:50.0\nredind = vcat(1:2:30,31:5:50,51:10:lastindex(r_arr)) # We evaluate the analytical solutions at a coarser grid to avoid overloading the plot.\n\nwfA(r,n) = Antique.R(CTB, r; n, l=0) # Exact wave function for the n-th state\n\np = plot(xlabel=\"\\$ r \\$\", ylabel=\"\\$ r^2\\\\,|\\\\psi(r)|^2 \\$\", title=\"Two-body radial s-wave densities\\n for a 3D Coulomb system\", guidefont=18,legendfont=10)\ndensity = zeros(length(r_arr),4)\ndensity_exact = zeros(length(r_arr),4)\nmarkers = [:circ, :square, :utriangle, :star]\nfor si = 1:4\n    wf = wfs[:,si]\n    psi_arr = GEM2B.wavefun_arr(r_arr,phys_params,num_params_opt,wf;cr_bool=0)\n\n    density[:,si] .= abs2.(psi_arr).*r_arr.^2\n    density_exact[:,si] = abs2.(wfA.(r_arr,si)).*r_arr.^2\n\n    scatter!(r_arr[redind],density_exact[redind,si],label=\"n=$(si), exact\", lw=2,color=si, marker=markers[si],markersize=3)\n    plot!(r_arr, density[:,si], label=\"n=$(si), num\", lw=2, color=si)\nend\n\np","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"The normalization of the wave function can be checked by integrating the density:","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"norms = density[:,1:4]'*fill(dr,lastindex(r_arr)) # A simple Riemann sum is sufficient here\nprintln(\"\\n6. Norms of the wave functions:\")\ncomparison(norms, ones(4), 4; s1=\"Norm\", s2=\"Exact\")","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"","category":"page"},{"location":"example3D/","page":"3D Example","title":"3D Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#FewBodyToolkit.jl","page":"Home","title":"FewBodyToolkit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Dev)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Julia package for solving quantum few-body systems of 2 or 3 particles with general potentials in various dimensions.","category":"page"},{"location":"#Features-and-modules-overview","page":"Home","title":"Features and modules overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The FewBodyToolkit.jl package currently provides three modules with the following features:","category":"page"},{"location":"#GEM2B-Two-body-solver-(1D,2D,3D)","page":"Home","title":"GEM2B - Two-body solver (1D,2D,3D)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Two-body systems in 1D, 2D, or 3D\nSymmetric interaction potentials of arbitrary shape\nReal- and complex-ranged Gaussian basis functions\nComplex scaling method (CSM) for resonances\nBasis optimization\nInverse problem: scaling the interaction to yield a desired eigenenergy\nCoupled-channel problems with additional derivative terms\nOutput of the wave function","category":"page"},{"location":"#GEM3B1D-Three-body-solver-(1D)","page":"Home","title":"GEM3B1D - Three-body solver (1D)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Three-body systems in 1D\nPair-interactions of arbitrary shape and symmetry (e.g. parity-violating)\nExpansion in up to three Fadeev components (rearrangement channels)\nAutomatic handling of identical particles (symmetrization, reduction of Faddeev components)\nComplex scaling method (CSM) for resonances","category":"page"},{"location":"#ISGL-Three-body-solver-(3D)","page":"Home","title":"ISGL - Three-body solver (3D)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Three-body systems in 3D\nCentral-symmetric pair-interactions of arbitrary shape\nExpansion in up to three Fadeev components (rearrangement channels)\nAutomatic handling of identical particles (symmetrization, reduction of Faddeev components)\nComplex scaling method (CSM) for resonances\nArbitrary high intrinsic angular momenta (computationally expensive for high values) via infinitesimally-shifted Gaussian basis functions\nOn-the-fly calculation of central observables and mean-square radii","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install FewBodyToolkit.jl you can use Julia's package manager","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"FewBodyToolkit\") # or ] add FewBodyToolkit","category":"page"},{"location":"#Usage-and-Examples","page":"Home","title":"Usage & Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All modules follow a similar usage pattern:","category":"page"},{"location":"","page":"Home","title":"Home","text":"1.Casting a few-body system in physical parameters: (reduced) masses, interactions, parity, etc. :","category":"page"},{"location":"","page":"Home","title":"Home","text":"# 2-body system in 3D, with reduced mass mur and potential as interaction\nusing FewBodyToolkit\npotential(r) = -10/(1+r)\nphys_params = make_phys_params2B(;mur=2.0,vint_arr=[potential],dim=3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"2.Setting up numerical parameters: number and range of Gaussian basis functions, complex-rotation angle, etc. :","category":"page"},{"location":"","page":"Home","title":"Home","text":"# 10 basis functions with minimum and maximum range parameters 0.5, and 30.0, respectively.\nnum_params = make_num_params2B(;gem_params=(nmax=10,r1=0.5,rnmax=30.0)) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"3.Solving the system using the solver provided by the corresponding module.","category":"page"},{"location":"","page":"Home","title":"Home","text":"energies, vectors = GEM2B_solve(phys_params, num_params; wf_bool=1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"4.Post-processing via Plots, optional calculation of wave-functions or mean value of observables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nrgrid = range(0.0,5.0,length=100)\nfirstexcited = GEM2B.wavefun_arr(rgrid,phys_params,num_params,vectors[:,2])\nplot(rgrid,firstexcited)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Explicit examples showing this procedure for each of the modules can be found under the Examples page with fully runnable scripts in the /examples subfolder of the repository.","category":"page"},{"location":"#Method-and-advanced-options","page":"Home","title":"Method and advanced options","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"More information on the underlying method and basis functions can be found under Gaussian Basis Functions. An explanation of advanced options are listed in Advanced options.","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the API section for a list of all exported types and functions.","category":"page"},{"location":"#Related-packages:","page":"Home","title":"Related packages:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Antique.jl - Analytical solutions to solvable quantum mechanical models\nFewBodyECG.jl - For coulombic few-body systems in 3D, using explicitly correlated Gaussians\nTwoBody.jl - Solutions to two-body systems using various methods, e.g. finite differences\nQMsolve - Solving and visualizing the Schrödinger equation in Python\nMOLSCAT -  Atom-molecule scattering in Fortran\nJPublicThreeBodySolver - Solver for Faddeev equations in Java","category":"page"},{"location":"1D_2+1/#21-system-in-1D","page":"1D: 2+1 system","title":"2+1 system in 1D","text":"","category":"section"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"This example reproduces the results in the article [2]. It studies a one-dimensional 2+1 system of two identical particles interacting with a third particle via a central potential. Here, we consider the interaction to be either a contact interaction or a Gaussian potential, which supports a weakly-bound ground state. The two identical particles do not interact.","category":"page"},{"location":"1D_2+1/#Setup","page":"1D: 2+1 system","title":"Setup","text":"","category":"section"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"using Printf, FewBodyToolkit","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"This function returns the universal energy ratios of Table I in the article for a given mass ratio:","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"function exfun(mr)\n    if mr == 2.2\n        return [-2.1966, -1.0520]\n    elseif mr == 12.4\n        return [-2.5963, -1.4818, -1.1970, -1.0377, -1.0002]\n    elseif mr == 22.2\n        return [-2.7515, -1.6904, -1.3604, -1.1479, -1.0525, -1.0040]\n    else\n        error(\"Unknown mass ratio: $mr\")\n    end\nend;\nnothing #hide","category":"page"},{"location":"1D_2+1/#Two-body-inverse-problem","page":"1D: 2+1 system","title":"Two-body inverse problem","text":"","category":"section"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"First we define the 2+1 system via the mass ratio. Here we choose 22.2 since it results in the most bound states. Feel free to change it to either 2.2 or 12.4.","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"massratio = 22.2 # other values are 2.2 and 12.4\nmass_arr = [1.0, massratio, massratio]\nmur = 1/(1/mass_arr[1]+1/mass_arr[2]) # reduced mass\nprintln(\"Mass ratio: \", massratio, \", reduced mass: \", round(mur,digits=4))","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"We need a potential whose ground state is weakly bound. Here, we use a Gaussian potential and set the target energy to -10^-3. Then, we find the required potential strength via the GEM2B code.","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"v0 = -1.0; mu_g = 1.0;\nvg = GaussianPotential(v0,mu_g)\n\nphys_params2B = make_phys_params2B(;mur,vint_arr=[vg],dim=1)\nnum_params2B = make_num_params2B(;gem_params=(;nmax=16, r1=1.0, rnmax=120.0))\n\nstateindex = 1; target_e2 = -1e-3;\nprintln(\"1. Two-body inverse problem\")\npps,nps,vscale = GEM2B.v0GEMOptim(phys_params2B,num_params2B,stateindex,target_e2)\nprintln(\"Found potential parameters: v0 = \", vscale*v0, \", mu_g = \", mu_g)","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"We define the rescaled potential and corresponding physical parameters","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"vgscaled = GaussianPotential(v0*vscale,mu_g)\npps = make_phys_params2B(;mur,vint_arr=[vgscaled],dim=1)","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"Check if the two-body system indeed has the desired binding energy:","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"e2s = GEM2B.GEM2B_solve(pps,nps)\nprintln(\"Two-body binding energy: \", e2s[1], \" (target: $(target_e2) )\")","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"We can also perform the calculation with a contact potential:","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"vc = ContactPotential1D(-sqrt(-2*target_e2),0.0)\nppc = make_phys_params2B(;mur,vint_arr=[vc],dim=1)\nnpc = make_num_params2B(;gem_params=(;nmax=16, r1=1.0, rnmax=120.0))","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"For a contact interaction we don't need to find the potential strength, but parameters should be optimized","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"r1cs,rnmaxcs,e2copt=GEM_Optim_2B(ppc,npc,stateindex)","category":"page"},{"location":"1D_2+1/#Three-body-problem","page":"1D: 2+1 system","title":"Three-body problem","text":"","category":"section"},{"location":"1D_2+1/#Two-identical-bosons","page":"1D: 2+1 system","title":"Two identical bosons","text":"","category":"section"},{"location":"1D_2+1/#Inputs","page":"1D: 2+1 system","title":"Inputs","text":"","category":"section"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"Having found the potential parameters, we can now set up the three-body problem with the scaled potential. For bosons we can use their symmetry with the argument svals=[\"x\",\"b\",\"b\"], where x is the different particle and b denotes two identical bosons.","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"vint_arr=[[],[vgscaled],[vgscaled]] #[[v23],[v31],[v12]]\nphys_params3B = make_phys_params3B1D(;mass_arr=mass_arr,svals=[\"x\",\"b\",\"b\"],vint_arr)","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"For the numerical parameters nmax, r1, and rnmax we use the optimized ones, found by the two-body inverse problem. The parameters for the other Jacobi coordinates are set manually.","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"nmax = nps.gem_params.nmax;\nr1 = nps.gem_params.r1; rnmax = nps.gem_params.rnmax;\nnum_params3B = make_num_params3B1D(;gem_params=(;nmax, r1, rnmax, Nmax=16, R1=1.5, RNmax=250.0))","category":"page"},{"location":"1D_2+1/#Solving-the-three-body-problem","page":"1D: 2+1 system","title":"Solving the three-body problem","text":"","category":"section"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"println(\"\\n2. Solving the three-body problem and comparing to the article's results\")\ne3 = GEM3B1D.GEM3B1D_solve(phys_params3B,num_params3B);\nnothing #hide","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"We compute the ratio of three-body to two-body binding energies.","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"println(\"Results for the bosonic case, mass ratio = $massratio\")\nepsilon = e3 /abs(e2s[1])\n\nex_arr = exfun(massratio)[1:2:end]\ncomparison(epsilon, ex_arr, min(length(epsilon),length(ex_arr)); s1=\"Gaussian\", s2=\"Contact (Ref.)\")","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"We can also do the calculation with a contact potential:","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"vint_arrC=[[],[vc],[vc]]\npp3BC = make_phys_params3B1D(;mass_arr=mass_arr,svals=[\"x\",\"b\",\"b\"],vint_arr = vint_arrC)\nnmax = nps.gem_params.nmax;\nnp3BC = make_num_params3B1D(;gem_params=(;nmax, r1=r1cs, rnmax=rnmaxcs, Nmax=16, R1=1.5, RNmax=250.0))\nprintln(\"\\nThree-body problem with contact potential\")\ne3c = GEM3B1D.GEM3B1D_solve(pp3BC,np3BC);\nepsilonC = e3c /abs(e2copt);\n\ncomparison(epsilonC, ex_arr, min(length(epsilonC),length(ex_arr)); s1=\"Contact (FBTK)\", s2=\"Contact (Ref.)\")","category":"page"},{"location":"1D_2+1/#Two-identical-fermions","page":"1D: 2+1 system","title":"Two identical fermions","text":"","category":"section"},{"location":"1D_2+1/#Inputs-2","page":"1D: 2+1 system","title":"Inputs","text":"","category":"section"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"For fermions we can use the same potential. To account for their different statistics and parity, we use svals=[\"x\",\"f\",\"f\"] and parity=-1. To allow for basis functions that obey these requirements, we need to set lmax, Lmax=1.","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"println(\"\\n3. Results for the fermionic case, mass ratio = $massratio\")\nphys_params3B_F = make_phys_params3B1D(;mass_arr=mass_arr,svals=[\"x\",\"f\",\"f\"],vint_arr,parity=-1)\nnum_params3B_F = make_num_params3B1D(;gem_params=(;nmax, r1, rnmax, Nmax=16, R1=1.5, RNmax=250.0), lmin=0, Lmin=0, lmax=1, Lmax=1)\ne3_F = GEM3B1D.GEM3B1D_solve(phys_params3B_F,num_params3B_F);\nnothing #hide","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"We compute the ratio of three-body to two-body binding energies.","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"epsilon_F = e3_F /abs(e2s[1])\n\nex_arr_F = exfun(massratio)[2:2:end]\ncomparison(epsilon_F, ex_arr_F, min(length(epsilon_F),length(ex_arr_F)); s1=\"Gaussian\", s2=\"Contact (Ref.)\")","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"Again, we can also do the calculation with a contact potential:","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"pp3BC = make_phys_params3B1D(;mass_arr=mass_arr,svals=[\"x\",\"f\",\"f\"],vint_arr = vint_arrC, parity=-1)\nnp3BC = make_num_params3B1D(;gem_params=(;nmax, r1=r1cs, rnmax=rnmaxcs, Nmax=16, R1=1.5, RNmax=250.0),lmin=0,Lmin=0,lmax=1,Lmax=1)\nprintln(\"\\nThree-body problem with contact potential\")\ne3c_F = GEM3B1D.GEM3B1D_solve(pp3BC,np3BC);\nepsilonC_F = e3c_F /abs(e2copt);\n\ncomparison(epsilonC_F, ex_arr_F, min(length(epsilonC_F),length(ex_arr_F)); s1=\"Contact (FBTK)\", s2=\"Contact (Ref.)\")","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"Overall, we can reproduce the article's results quite well for both bosonic and fermionic systems. For the contact interaction, the results match within the provided accuracy. For the Gaussian interaction, better results could be obtained with more basis functions and/or optimized basis parameters. Note, however, that perfect agreement between the finite-range Gaussian interaction and the contact interaction cannot be reached. Only in the limit of vanishing two-body binding energy, the two potentials should yield the same results.","category":"page"},{"location":"1D_2+1/#Page-References","page":"1D: 2+1 system","title":"Page References","text":"","category":"section"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"L. Happ, M. Zimmermann, S. I. Betelu, W. P. Schleich and M. A. Efremov. Universality in a one-dimensional three-body system. Phys. Rev. A 100, 012709 (2019).\n\n\n\n","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"See also the full bibliography for further references cited throughout this documentation.","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"","category":"page"},{"location":"1D_2+1/","page":"1D: 2+1 system","title":"1D: 2+1 system","text":"This page was generated using Literate.jl.","category":"page"}]
}
